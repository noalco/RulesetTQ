<DocumentElement xmlns="http://tempuri.org/Ruleset.xsd">
  <Scripts>
    <ScriptName>npc_skills</ScriptName>
    <FolderID>29</FolderID>
    <Script>-- 
-- Please see the license.html file included with this distribution for 
-- attribution and copyright information.
--

local bParsed = false;
local aComponents = {};

-- The nDragMod and sDragLabel fields keep track of the entry under the cursor
local sDragLabel = nil;
local nDragMod = nil;
local bDragging = false;
local sDado="1d10";

function getCompletion(s)
	-- Find a matching completion for the given string
	for k,_ in pairs(DataCommon.skilldata) do
		if string.lower(s) == string.lower(string.sub(k, 1, #s)) then
			return string.sub(k, #s + 1);
		end
	end

	return "";
end

function onValueChanged()
	
	-- Parse the value string
	parseComponents();

end

function parseComponents()
	aComponents = {};
	local nCaracteresDobles=0; local count=0;
	
	-- Get the comma-separated strings
	local aClauses, aClauseStats = StringManager.split(getValue(), ",;\r\n", true);
	
	-- Check each comma-separated string for a potential skill roll or auto-complete opportunity
	for i = 1, #aClauses do
		local nStarts, nEnds, sLabel, sSign, sMod = string.find(aClauses[i], "([%a%s:ñÑáÁéÉíÍóÓúÚ]+)%s*([%+%-–]?)(%d*)");
		if sSign=="" then nStarts, nEnds, sLabel, sMod = string.find(aClauses[i], "([%a%s:ñÑáÁéÉíÍóÓúÚ]+)%s*(%d*)"); end

		_,count = string.gsub(aClauses[i], "[ñÑáÁéÉíÍóÓúÚ]", "");
		nCaracteresDobles=nCaracteresDobles+count/2;

		if nStarts then
			-- Calculate modifier based on mod value and sign value, if any
			local nAllowRoll = 0;
			local nMod = 0;
			if sMod ~= "" then
				nAllowRoll = 1;
				nMod = tonumber(sMod) or 0;
				if sSign == "-" or sSign == "–" then
					nMod = 0 - nMod;
				end
			end

			-- Insert the possible skill into the skill list
			table.insert(aComponents, {nStart = aClauseStats[i].startpos - nCaracteresDobles, nLabelEnd = aClauseStats[i].startpos + nEnds - nCaracteresDobles, nEnd = aClauseStats[i].endpos - nCaracteresDobles, sLabel = sLabel, nMod = nMod, nAllowRoll = nAllowRoll });
		end
	end
	
	bParsed = true;
end

function onChar(nKeyCode)
--	bParsed = false;
--	
--	local nCursor = getCursorPosition();
--	local sValue = getValue();
--	local sCompletion;
--	
--	-- If alpha character, then build a potential autocomplete
--	if ((nKeyCode &gt;= 65) and (nKeyCode &lt;= 90)) or ((nKeyCode &gt;= 97) and (nKeyCode &lt;= 122)) then
--		-- Parse the value string
--		parseComponents();
--
--		-- Build auto-complete for the current string
--		for i = 1, #aComponents, 1 do
--			if nCursor == aComponents[i].nLabelEnd then
--				sCompletion = getCompletion(aComponents[i].sLabel);
--				if sCompletion ~= "" then
--					local sNewValue = sValue:sub(1, getCursorPosition()-1) .. sCompletion .. sValue:sub(getCursorPosition());
--					setValue(sNewValue);
--					setSelectionPosition(nCursor + #sCompletion);
--				end
--
--				return;
--			end
--		end
--
--	-- Or else if space character, then finish the autocomplete
--	else
--		if ((nKeyCode == 32) and (nCursor &gt;= 2)) then
--			-- Parse the value string
--			parseComponents();
--			
--			-- Find any string we may have just auto-completed
--			local nLastCursor = nCursor - 1;
--			for i = 1, #aComponents, 1 do
--				if nCursor - 1 == aComponents[i].nLabelEnd then
--					sCompletion = getCompletion(aComponents[i].sLabel);
--					if sCompletion ~= "" then
--						local sNewValue = string.sub(sValue, 1, nLastCursor - 1) .. sCompletion .. string.sub(sValue, nLastCursor);
--						setValue(sNewValue);
--						setCursorPosition(nCursor + #sCompletion);
--						setSelectionPosition(nCursor + #sCompletion);
--					end
--
--					return;
--				end
--			end
--		end
--	end
end

-- Reset selection when the cursor leaves the control
function onHover(bOnControl)
	if bDragging or bOnControl then
		return;
	end

	sDragLabel = nil;
	nDragMod = nil;
	setSelectionPosition(0);
end

-- Hilight skill hovered on
function onHoverUpdate(x, y)
	if bDragging then
		return;
	end

	if not bParsed then
		parseComponents();
	end
	local nMouseIndex = getIndexAt(x, y);

	for i = 1, #aComponents, 1 do
		if aComponents[i].nAllowRoll == 1 then
			if aComponents[i].nStart &lt;= nMouseIndex and aComponents[i].nEnd &gt; nMouseIndex then
				setCursorPosition(aComponents[i].nStart);
				setSelectionPosition(aComponents[i].nEnd);

				sDragLabel = aComponents[i].sLabel;
				nDragMod = aComponents[i].nMod;
				setHoverCursor("hand");
				return;
			end
		end
	end
	
	sDragLabel = nil;
	nDragMod = nil;
	setHoverCursor("arrow");
end

--function action(draginfo)
--	if sDragLabel then
--		local rActor = ActorManager.resolveActor(window.getDatabaseNode());
--		performRoll(draginfo, rActor, sDragLabel, nDragMod);
--	end
--end

function action(dragInfo)
	if sDragLabel then
		DiceRollString = sDado.."!+"..nDragMod;
		DiceRollDescription = "[Habilidad] " .. sDragLabel;
		GameSystem.actions["HabilidadRollAction"] = { bUseModStack = "true" }
		DiceRollAdditionalInfo = {};
		if onBeforeDiceRoll then if onBeforeDiceRoll() == false then return; end; end;
		local windataref = window.getDatabaseNode();
		if windataref == nil then windataref = window; end;
		RulesetWizardDiceRoller.Roll(dragInfo, windataref,"HabilidadRollAction", DiceRollDescription, DiceRollString, getValue(), DiceRollAdditionalInfo);
		ModifierStack.reset();
		if onAfterDiceRoll then onAfterDiceRoll(); end;
		return true;
	end
end

function onDoubleClick(x, y)
	action();
	return true;
end

function onDragStart(button, x, y, draginfo)
	action(draginfo);

	bDragging = true;
	setCursorPosition(0);
	
	return true;
end

function onDragEnd(draginfo)
	bDragging = false;
end

-- Suppress default processing to support dragging
function onClickDown(button, x, y)
	return true;
end

-- On mouse click, set focus, set cursor position and clear selection
function onClickRelease(button, x, y)
	setFocus();
	
	local n = getIndexAt(x, y);
	setSelectionPosition(n);
	setCursorPosition(n);
	
	return true;
end

function performRoll(draginfo, rActor, sSkillName, nSkillMod)
	local rRoll = getRoll(rActor, sSkillName, nSkillMod, sSkillStat, sExtra);
	
	if Session.IsHost and CombatManager.isCTHidden(ActorManager.getCTNode(rActor)) then
		rRoll.bSecret = true;
	end
	
	ActionsManager.performAction(draginfo, rActor, rRoll);
end

function getRoll(rActor, sSkillName, nSkillMod)
	local rRoll = {};
	rRoll.sType = "habilidad";
	rRoll.aDice = { "d10" };
	rRoll.nMod = nSkillMod or 0;
	rRoll.sDesc = "[Habilidad] " .. sSkillName;

	return rRoll;
end

function onRoll(rSource, rTarget, rRoll)
	local rMessage = ActionsManager.createActionMessage(rSource, rRoll);
	
	local nTotal = ActionsManager.total(rRoll);
	Comm.deliverChatMessage(rMessage);
end

function onInit()
	ActionsManager.registerResultHandler("habilidad", onRoll);
end

function Devilitado(bDebilitado)
	if bDebilitado then sDado="1d6";
	else sDado="1d10";
	end
end
</Script>
    <RegisterScript>false</RegisterScript>
    <Encoding />
  </Scripts>
</DocumentElement>